/* -*- Mode: js; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */

// JavaScript predictive text engine.
//
// This predictive text engine was contributed by Christoph Kerschbaumer
// and is losely based on the following literature:
//
// http://www.strchr.com/ternary_dags
//
// A note on the dictionary format: The prediction engine uses a custom binary
// dictionary format that is generated by xml2tst.py from a XML-based word
// lists. The word lists included with this engine are minimally modified
// versions of the word lists that ship with Android Jelly Bean (4.1). The
// lists are licensed under the Apache license, as is this engine.
//
// Consult xml2dict.py to understand the format of the dictionary file. The
// purpose of the dictionary file is to compactly represent the ternary
// search tree.
// We use the binary representation of the tst instead of building a tst
// out of JS objects because JS objects tend to occupy much
// more memory than the binary format xml2tst.py generates.
//
// This module defines a single global variable Predictions which is an
// object with the following methods:
//
//   setDictionary: specifies the dictionary to use
//
//   setLayout: TODO:// not needed anymore
//
//   predict: given an input string, return the most likely
//      completions or corrections for it.
//
'use strict';

var Predictions = (function() {

  var _dict; // the dictionary for the current language
  var _currentWord = ''; // the word currently being edited
  var _maxLookAhead = 6; // stop traversing the tree once we hit this length 
  var _maxSuggestions = 3; // max number of suggestions to be returned

  // Send a log message to the main thread since we can't output to the console
  // directly.
  function log(msg) {
    self.postMessage({ cmd: 'log', args: [msg] });
  }

  const SearchTST = (function() {

    const chIdx = 0;
    const lChildIdx = 1;
    const cChildIdx = 2;
    const rChildIdx = 3;
    const freqIdx = 4;

    // traverse the tst using DFS to find all possible candidates
    // starting with the given prefix
    function findPredictionsDFS(offset, match, candidates) {
      // var splitChar = _dict[offset];
      var lChild = _dict[offset + lChildIdx];
      var cChild = _dict[offset + cChildIdx];
      var rChild = _dict[offset + rChildIdx];
      var frequency = _dict[offset + freqIdx];

      // dump ("DFS, ch: " + String.fromCharCode(splitChar));
      // dump (", l: " + lChild);
      // dump (", c: " + cChild);
      // dump (", r: " + rChild);
      // dump (", f: " + frequency + "\n");

      if (match.length > _currentWord.length + _maxLookAhead)
        return;

      if (frequency != 0 && match.length > _currentWord.length)
        candidates.push({ word : match, freq : frequency });

      if (cChild == 0 && lChild == 0 && rChild == 0)
        return;

      if (cChild != 0) {
        var cChar = String.fromCharCode(_dict[offset + cChild]);
        findPredictionsDFS(offset + cChild, match + cChar, candidates);
      }

      if (lChild != 0) {
        var lChar = String.fromCharCode(_dict[offset + lChild]);
        findPredictionsDFS(offset + lChild, match.substring(0, match.length - 1) + lChar, candidates);
      }

      if (rChild != 0) {
        var rChar = String.fromCharCode(_dict[offset + rChild]);
        findPredictionsDFS(offset + rChild, match.substring(0, match.length - 1) + rChar, candidates);
      }
    }

    function predict(offset, prefix, match, suggestions) {
      var splitChar = _dict[offset]; // character code
      var lChild = _dict[offset+lChildIdx];
      var cChild = _dict[offset+cChildIdx];
      var rChild = _dict[offset+rChildIdx];
      var frequency = _dict[offset+freqIdx];

      // dump ("predict, ch: " + String.fromCharCode(splitChar));
      // dump (", l: " + lChild);
      // dump (", c: " + cChild);
      // dump (", r: " + rChild);
      // dump (", f: " + frequency + "\n");

      var ch = prefix[0];

      if (ch.charCodeAt(0) < splitChar) {
        if (lChild != 0) {
          predict(offset + lChild, prefix, match, suggestions);
        }
      }
      else if (ch.charCodeAt(0) > splitChar) {
        if (rChild != 0) {
          predict(offset + rChild, prefix, match, suggestions);
        }
      }
      else {
        if (prefix.length == 1) {
          if (frequency != 0 && match.length > _currentWord.length) {
            suggestions.push({ word : match, freq : frequency });
          }
          if (cChild != 0) {
            var cChar = String.fromCharCode(_dict[offset + cChild]);
            findPredictionsDFS(offset + cChild, match + String.fromCharCode(splitChar) + cChar, suggestions);
          }
          return;
        }
        if (cChild != 0) {
          predict(offset + cChild, prefix.substring(1), match + ch, suggestions);
        }
      }
    }

    return (function(prefix, candidates) {
      predict(0, prefix, '', candidates); 
    });
  })();

  function maintainTopCandidates(topCandidates, candidate) {
    var length = topCandidates.length;
    var index = length;
    for (var i = length - 1; i >= 0; i--) {
      if (candidate.word == topCandidates[i].word)
        return;
      if (candidate.freq > topCandidates[i].freq)
        index = i;
    }
    if (index >= _maxSuggestions)
      return;
    topCandidates.splice(index, 0, candidate);
    if (topCandidates.length > _maxSuggestions)
      topCandidates.length = _maxSuggestions;
  }
 
  function Predict(word) {
    _currentWord = word;
    var candidates = [];
 
    SearchTST(word, candidates);

    // rank candidates
    var finalCandidates = [];
    for (var n = 0, len = candidates.length; n < len; ++n) {
      var candidate = candidates[n];
      maintainTopCandidates(finalCandidates, candidate);
    }
    return finalCandidates;
  }

  function setDictionary(dict) {
    _dict = Int32Array(dict);
  }

  function setLayout(params) {
    // TODO: not needed anymore
  }

  // Return an array of predictions for the given prefix
  function predict(prefix) {
    if (!_dict) {
      throw Error('not initialized');
    }

    // Get the raw predictions
    var predictions = Predict(prefix);
    var finalPredictions = [];
    // Extract just the words and return an array of strings
    for (var n = 0, len = predictions.length; n < len; ++n) {
      finalPredictions.push(predictions[n].word);
    }
    return finalPredictions;
  }

  return {
    setDictionary: setDictionary,
    setLayout: setLayout,
    predict: predict
  };
}());
