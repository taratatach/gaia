/* -*- Mode: js; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */

// JavaScript predictive text engine.
//
// This predictive text engine was contributed by Christoph Kerschbaumer
// and is losely based on the following literature:
//
// http://www.strchr.com/ternary_dags
//
// A note on the dictionary format: The prediction engine uses a custom binary
// dictionary format that is generated by xml2dict.py from a XML-based word
// lists. The word lists included with this engine are minimally modified
// versions of the word lists that ship with Android Jelly Bean (4.1). The
// lists are licensed under the Apache license, as is this engine.
//
// Consult xml2dict.py to understand the format of the dictionary file. The
// purpose of the dictionary file is to compactly represent the ternary
// search tree.
// We use the binary representation of the tst instead of building a tst
// out of JS objects because JS objects tend to occupy much
// more memory than the binary format xml2dict.py generates.
//
// This module defines a single global variable Predictions which is an
// object with the following methods:
//
//   setDictionary: specifies the dictionary to use
//
//   setLayout: specifies the keyboard layout, which is used to
//      determine the set of nearby keys for each key
//
//   predict: given an input string, return the most likely
//      completions or corrections for it.
//
'use strict';

var Predictions = (function() {

  var _dict; // the dictionary for the current language
  var _nearbyKeys; // nearby keys for any given key
  var _altKeys;
  var _currentWordLength = 0; // the current word length
  var _prefixMatchMultiplier = 1.5; // if prefix matches, push for that candidate
  var _maxLookAhead = 2; // stop traversing the tree once we hit this length
  var _maxSuggestions = 3; // max number of suggestions to be returned
  var _maxWordLength = 32;

  // Send a log message to the main thread since we can't output to the console
  // directly.
  function log(msg) {
    self.postMessage({ cmd: 'log', args: [msg] });
  }

  // Calculate the squared distance of a point (x, y) to the nearest edge of
  // a rectangle (left, top, width, height). This is used to calculate the
  // nearby keys for every key. We search the dictionary by looking for words
  // where each character corresponds to the key the user touched, or a key
  // near that key.
  function SquaredDistanceToEdge(left, top, width, height, x, y) {
    var right = left + width;
    var bottom = top + height;
    var edgeX = x < left ? left : (x > right ? right : x);
    var edgeY = y < top ? top : (y > bottom ? bottom : y);
    var dx = x - edgeX;
    var dy = y - edgeY;
    return dx * dx + dy * dy;
  }

  // Determine whether the key is a special character or a regular letter.
  // Special characters include backspace (8), return (13), and space (32).
  function SpecialKey(key) {
    var code = key.code;
    // codes: 'a' = 97, 'z' = 122
    return code < 97 || code > 122;
  }

  // Generate an array of char codes from a word.
  function String2Codes(codes, word) {
    for (var n = 0, len = word.length; n < len; ++n)
      codes[n] = word.charCodeAt(n);
    return codes;
  }

  // Convert an array of char codes back into a string.
  function Codes2String(codes) {
    return String.fromCharCode.apply(String, codes);
  }

  const SearchTST = (function() {

    const lChildIdx = 1;
    const cChildIdx = 2;
    const rChildIdx = 3;

    // The 'char' and 'frequency' can share a 32bit-union
    // the upper 16 hold the frequency, the lower 16 the char.
    function extractCharFromUnion(union) {
      return union & 0xffff;
    }

    function extractFrequencyFromUnion(union) {
      return (union >> 16) & 0xffff;
    }

    // Traverse the tst using DFS to find all possible candidates
    // starting with the given prefix
    function findPredictionsDFS(offset, match, candidates, orig) {
      var frequency = extractFrequencyFromUnion(_dict[offset]);
      var lChild = _dict[offset + lChildIdx];
      var cChild = _dict[offset + cChildIdx];
      var rChild = _dict[offset + rChildIdx];

      var matchLength = match.length;

      if (matchLength > _currentWordLength + _maxLookAhead)
        return;

      if (frequency != 0) {
        if (orig)
          frequency *= _prefixMatchMultiplier;
        candidates.push({ word : match, freq : frequency });
      }

      if (cChild != 0) {
        var cChar = String.fromCharCode(_dict[offset + cChild]);
        findPredictionsDFS(offset + cChild, match + cChar, candidates, orig);
      }

      if (lChild != 0) {
        var lChar = String.fromCharCode(_dict[offset + lChild]);
        findPredictionsDFS(offset + lChild,
                           match.substring(0, matchLength - 1) + lChar,
                           candidates, orig);
      }

      if (rChild != 0) {
        var rChar = String.fromCharCode(_dict[offset + rChild]);
        findPredictionsDFS(offset + rChild,
                           match.substring(0, matchLength - 1) + rChar,
                           candidates, orig);
      }
    }

    // Generate a candidate by adding a character
    function addChars(offset, prefix, prefixLen, match, suggestions) {
      var matchLength = match.length;
      // move() works like memcpy, we move all charCodes to the right
      // to make room for adding one character
      prefix.move(matchLength, prefix.length - matchLength - 1, matchLength + 1);
      for (var nkey in _nearbyKeys) {
        prefix[matchLength] = nkey.charCodeAt(0);
        predict(offset, prefix, prefixLen + 1, match, suggestions, false);
      }
      // move the memory back where it was
      prefix.move(matchLength + 1, prefix.length - matchLength - 1, matchLength);
    }

    // Generate a candidate by removing a character
    function removeChars(offset, prefix, prefixLen, match, suggestions) {
      var matchLength = match.length;
      var removed = prefix[matchLength];
      prefix.move(matchLength + 1, prefix.length - matchLength - 1, matchLength);
      predict(offset, prefix, prefixLen - 1, match, suggestions, false);
      prefix.move(matchLength, prefix.length - matchLength - 1, matchLength + 1);
      prefix[matchLength] = removed;
    }

    // Generate a candidate by replacing a character with its
    // surrounding characters (editdistance 1)
    function surroundingChars(offset, prefix, prefixLen, match, suggestions) {
      var matchLength = match.length;
      var nearbyKeys = _nearbyKeys[String.fromCharCode(prefix[matchLength])];
      if (typeof(nearbyKeys) === 'undefined')
        return;
      var original = prefix[matchLength];
      var replace;
      for (var i = 0, len = nearbyKeys.length; i < len; ++i) {
        replace = nearbyKeys[i].charCodeAt(0);
        if (original == replace)
          continue;
        prefix[matchLength] = replace;
        predict(offset, prefix, prefixLen, match, suggestions, false);
      }
      prefix[matchLength] = original;
    }

    // Generate a candidate by replacing a character with its
    // alternative characters (diacritics)
    function alternativeChars(offset, prefix, prefixLen, match, suggestions) {
      var matchLength = match.length;
      var altKeys = _altKeys[String.fromCharCode(prefix[matchLength])];
      if (typeof(altKeys) === 'undefined')
        return;
      var original = prefix[matchLength];
      var replace;
      for (var i = 0, len = altKeys.length; i < len; ++i) {
        replace = altKeys[i].charCodeAt(0);
        if (original == replace)
          continue;
        prefix[matchLength] = replace;
        predict(offset, prefix, prefixLen, match, suggestions, false);
      }
      prefix[matchLength] = original;
    }

    // Generate a candidate by transposing its characters
    function transposeChars(offset, prefix, prefixLen, match, suggestions) {
      var matchLength = match.length;
      var idx1 = prefix[matchLength];
      var idx2 = prefix[matchLength + 1];
      prefix[matchLength] = idx2;
      prefix[matchLength + 1] = idx1;
      predict(offset, prefix, prefixLen, match, suggestions, false);
      prefix[matchLength] = idx1;
      prefix[matchLength + 1] = idx2;
    }

    // orig indicates that the prefix was not modified through
    // insertion, deletion, transposition of characters
    function predict(offset, prefix, prefixLen, match, suggestions, orig) {

      var matchLength = match.length;

      if (matchLength > prefixLen)
        return;

      var union = _dict[offset];
      var splitChar = extractCharFromUnion(union); // character code
      var frequency = extractFrequencyFromUnion(union);
      var lChild = _dict[offset + lChildIdx];
      var cChild = _dict[offset + cChildIdx];
      var rChild = _dict[offset + rChildIdx];
      
      var ch = prefix[matchLength];

      if (ch == splitChar) {
        var chStr = String.fromCharCode(ch);

        if (cChild != 0) {
          var coffset = offset + cChild;
          var cmatch = match + chStr;

          if (prefixLen - matchLength == 1) {
            if (frequency != 0)
              suggestions.push({ word : match + chStr, freq: frequency });

            var cChar = String.fromCharCode(_dict[coffset]);
            findPredictionsDFS(coffset, cmatch + cChar, suggestions, orig);
            return;
          }
          predict(coffset, prefix, prefixLen, cmatch, suggestions, orig);

          if (orig && prefixLen > 1) {
            addChars(coffset, prefix, prefixLen, cmatch, suggestions);
            removeChars(coffset, prefix, prefixLen, cmatch, suggestions);

            if (prefixLen >= 2) {
              surroundingChars(coffset, prefix, prefixLen, cmatch, suggestions);
              alternativeChars(coffset, prefix, prefixLen, cmatch, suggestions);
              if (prefixLen >= 3) {
                transposeChars(coffset, prefix, prefixLen, cmatch, suggestions);
              }
            }
          }
        }
      }

      // traverse the left and right childnodes
      if (ch < splitChar && lChild != 0) {
        predict(offset + lChild, prefix, prefixLen, match, suggestions, orig);
      }
      if (ch > splitChar && rChild != 0) {
        predict(offset + rChild, prefix, prefixLen, match, suggestions, orig);
      }
    }

    function getPredictions(prefix, suggestions) {
      var prefixLen = prefix.length;

      // we can only handle words up to _maxWordLength - 1
      // because we squeeze in a character when generating candidates
      if (prefixLen > _maxWordLength - 1)
        return;

      var input = String2Codes(new Uint32Array(_maxWordLength), prefix);
      predict(0, input, prefixLen, '', suggestions, true);

      if (suggestions.length >= 3)
        return;

      // if we don't find at least 3 candidates, we replace
      // the first character with all possible upper and
      // lower case characters
      var original = input[0];
      var replace;
      for (var altkey in _nearbyKeys) {
        replace = altkey.charCodeAt(0);
        if (original != replace) {
          input[0] = replace;
          predict(0, input, prefixLen, '', suggestions, false);
        }
        replace = altkey.toUpperCase().charCodeAt(0);
        if (original != replace) {
          input[0] = replace;
          predict(0, input, prefixLen, '', suggestions, false);
        }
      }
      
      if (suggestions.length >= 3)
        return;

      // if we still don't have at least 3 candidates, we replace
      // the first character with available diacritics for
      // that character.
      var altkeys = _altKeys[prefix[0]];
      if (typeof(altkeys) === 'undefined')
        return;

      for (var altkey in altkeys) {
        input[0] = altkey.charCodeAt(0);
        predict(0, input, prefixLen, '', suggestions, false);
      }
    }

    return (function(prefix, candidates) {
      getPredictions(prefix, candidates);
    });
  })();

  function maintainTopCandidates(topCandidates, candidate) {
    var length = topCandidates.length;
    var index = length;
    for (var i = length - 1; i >= 0; i--) {
      if (candidate.word == topCandidates[i].word)
        return;
      if (candidate.freq > topCandidates[i].freq)
        index = i;
    }
    if (index >= _maxSuggestions)
      return;
    topCandidates.splice(index, 0, candidate);
    if (topCandidates.length > _maxSuggestions)
      topCandidates.length = _maxSuggestions;
  }
 
  function Predict(word) {
    _currentWordLength = word.length;
    var candidates = [];
 
    SearchTST(word, candidates);

    // rank candidates
    var finalCandidates = [];
    for (var n = 0, len = candidates.length; n < len; ++n) {
      var candidate = candidates[n];
      maintainTopCandidates(finalCandidates, candidate);
    }
    return finalCandidates;
  }

  function setDictionary(dict) {
    _dict = Int32Array(dict);
  }

  function setLayout(params) {
    // Set all alternative keys (diacritics) for that key
    // separate upper and lower case values
    _altKeys = {};
    var altMap = params.alternativeKeys;
    for (var key in altMap) {
      if (SpecialKey(key))
        continue;
      _altKeys[key] = altMap[key];
      if (_altKeys[key.toUpperCase()] === undefined) {
        _altKeys[key.toUpperCase()] = altMap[key].toUpperCase();
      }
    }

    // For each key, calculate the keys nearby.
    var keyWidth = params.keyWidth;
    var keyHeight = params.keyHeight;
    var threshold = Math.min(keyWidth, keyHeight) * 1.2;
    var keyArray = params.keyArray;
    _nearbyKeys = {};
    threshold *= threshold;
    for (var n = 0; n < keyArray.length; ++n) {
      var key1 = keyArray[n];
      if (SpecialKey(key1))
        continue;
      var list = '';
      for (var m = 0; m < keyArray.length; ++m) {
        var key2 = keyArray[m];
        if (SpecialKey(key2))
          continue;
        if (SquaredDistanceToEdge(/* key dimensions */
          key1.x, key1.y,
          key1.width, key1.height,
          /* center of candidate key */
          key2.x + key2.width / 2,
          key2.y + key2.height / 2) <
            threshold) {
          list += String.fromCharCode(key2.code).toLowerCase();
        }
      }
      _nearbyKeys[String.fromCharCode(key1.code).toLowerCase()] = list;
    }
  }

  // Return an array of predictions for the given prefix
  function predict(prefix) {
    if (!_dict || !_nearbyKeys) {
      throw Error('not initialized');
    }

    // Get the raw predictions
    var predictions = Predict(prefix);
  
    var finalPredictions = [];

    // Extract just the words and return an array of strings
    for (var n = 0, len = predictions.length; n < len; ++n) {
      finalPredictions.push(predictions[n].word);
    }
    return finalPredictions;
  }

  return {
    setDictionary: setDictionary,
    setLayout: setLayout,
    predict: predict
  };
}());
