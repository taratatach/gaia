/* -*- Mode: js; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */

// JavaScript predictive text engine.
//
// This predictive text engine was contributed by Christoph Kerschbaumer
// and is losely based on the following literature:
//
// http://www.strchr.com/ternary_dags
//
// A note on the dictionary format: The prediction engine uses a custom binary
// dictionary format that is generated by xml2dict.py from a XML-based word
// lists. The word lists included with this engine are minimally modified
// versions of the word lists that ship with Android Jelly Bean (4.1). The
// lists are licensed under the Apache license, as is this engine.
//
// Consult xml2dict.py to understand the format of the dictionary file. The
// purpose of the dictionary file is to compactly represent the ternary
// search tree.
// We use the binary representation of the tst instead of building a tst
// out of JS objects because JS objects tend to occupy much
// more memory than the binary format xml2dict.py generates.
//
// This module defines a single global variable Predictions which is an
// object with the following methods:
//
//   setDictionary: specifies the dictionary to use
//
//   setLayout: specifies the keyboard layout, which is used to
//      determine the set of nearby keys for each key
//
//   predict: given an input string, return the most likely
//      completions or corrections for it.
//
'use strict';

var Predictions = (function() {

  var _dict; // the dictionary for the current language
  var _nearbyKeys; // nearby keys for any given key
  var _currentWord = ''; // the word currently being edited
  var _prefixMatchMultiplier = 1.5; // if prefix matches, push for that candidate
  var _maxLookAhead = 2; // stop traversing the tree once we hit this length
  var _maxSuggestions = 3; // max number of suggestions to be returned
  var _maxWordLength = 32;

  var _diacritics = {
    'a':'ÁáĂăǍǎÂâÄäȦȧẠạȀȁÀàẢảȂȃĀāĄąÅåḀḁȺⱥÃãǼǽǢǣÆæ',
    'b':'ḂḃḄḅƁɓḆḇɃƀƂƃ',
    'c':'ĆćČčÇçĈĉĊċƇƈȻȼ',
    'd':'ĎďḐḑḒḓḊḋḌḍƊɗḎḏĐđƋƌð',
    'e':'ÉéĔĕĚěȨȩÊêḘḙËëĖėẸẹȄȅÈèẺẻȆȇĒēĘę',
    'f':'ḞḟƑƒ',
    'g':'ǴǵĞğǦǧĢģĜĝĠġƓɠḠḡǤǥ',
    'h':'ḪḫȞȟḨḩĤĥⱧⱨḦḧḢḣḤḥĦħ',
    'i':'ÍíĬĭǏǐÎîÏïỊịȈȉÌìỈỉȊȋĪīĮįƗɨĨĩḬḭı',
    'j':'ĴĵɈɉ',
    'k':'ḰḱǨǩĶķⱩⱪꝂꝃḲḳƘƙḴḵꝀꝁ',
    'l':'ĹĺȽƚĽľĻļḼḽḶḷⱠⱡꝈꝉḺḻĿŀⱢɫŁł',
    'm':'ḾḿṀṁṂṃⱮɱ',
    'n':'ŃńŇňŅņṊṋṄṅṆṇǸǹƝɲṈṉȠƞÑñ',
    'o':'ÓóŎŏǑǒÔôÖöȮȯỌọŐőȌȍÒòỎỏƠơȎȏꝊꝋꝌꝍŌōǪǫØøÕõŒœ',
    'p':'ṔṕṖṗꝒꝓƤƥⱣᵽꝐꝑ',
    'q':'Ꝗꝗ',
    'r':'ŔŕŘřŖŗṘṙṚṛȐȑȒȓṞṟɌɍⱤɽ',
    's':'ŚśŠšŞşŜŝȘșṠṡṢṣß$',
    't':'ŤťŢţṰṱȚțȾⱦṪṫṬṭƬƭṮṯƮʈŦŧ',
    'u':'ÚúŬŭǓǔÛûṶṷÜüṲṳỤụŰűȔȕÙùỦủƯưȖȗŪūŲųŮůŨũṴṵ',
    'v':'ṾṿƲʋṼṽ',
    'w':'ẂẃŴŵẄẅẆẇẈẉẀẁⱲⱳ',
    'x':'ẌẍẊẋ',
    'y':'ÝýŶŷŸÿẎẏỴỵỲỳƳƴỶỷỾỿȲȳɎɏỸỹ',
    'z':'ŹźŽžẐẑⱫⱬŻżẒẓȤȥẔẕƵƶ'
  };

  // Send a log message to the main thread since we can't output to the console
  // directly.
  function log(msg) {
    self.postMessage({ cmd: 'log', args: [msg] });
  }

  // Calculate the squared distance of a point (x, y) to the nearest edge of
  // a rectangle (left, top, width, height). This is used to calculate the
  // nearby keys for every key. We search the dictionary by looking for words
  // where each character corresponds to the key the user touched, or a key
  // near that key.
  function SquaredDistanceToEdge(left, top, width, height, x, y) {
    var right = left + width;
    var bottom = top + height;
    var edgeX = x < left ? left : (x > right ? right : x);
    var edgeY = y < top ? top : (y > bottom ? bottom : y);
    var dx = x - edgeX;
    var dy = y - edgeY;
    return dx * dx + dy * dy;
  }

  // Determine whether the key is a special character or a regular letter.
  // Special characters include backspace (8), return (13), and space (32).
  function SpecialKey(key) {
    var code = key.code;
    return code <= 32;
  }

  // Generate an array of char codes from a word.
  function String2Codes(codes, word) {
    for (var n = 0, len = word.length; n < len; ++n)
      codes[n] = word.charCodeAt(n);
    return codes;
  }

  // Convert an array of char codes back into a string.
  function Codes2String(codes) {
    return String.fromCharCode.apply(String, codes);
  }

  const SearchTST = (function() {

    const chIdx = 0;
    const lChildIdx = 1;
    const cChildIdx = 2;
    const rChildIdx = 3;
    const freqIdx = 4;

    // Traverse the tst using DFS to find all possible candidates
    // starting with the given prefix
    function findPredictionsDFS(offset, match, candidates, origPrefix) {
      var lChild = _dict[offset + lChildIdx];
      var cChild = _dict[offset + cChildIdx];
      var rChild = _dict[offset + rChildIdx];
      var frequency = _dict[offset + freqIdx];

      if (match.length > _currentWord.length + _maxLookAhead)
        return;

      if (frequency != 0) {
        // we need this for simple word corrections: 'wsa' -> 'was'
        if (!origPrefix && match.length >= _currentWord.length)
           candidates.push({ word : match, freq : frequency });

        // if the original prefix matches, we have to push for that candidate
        else if (origPrefix && match.length > _currentWord.length) {
          frequency *= _prefixMatchMultiplier;
          candidates.push({ word : match, freq : frequency });
        }
      }

      if (cChild != 0) {
        var cChar = String.fromCharCode(_dict[offset + cChild]);
        findPredictionsDFS(offset + cChild, match + cChar, candidates, origPrefix);
      }

      if (lChild != 0) {
        var lChar = String.fromCharCode(_dict[offset + lChild]);
        findPredictionsDFS(offset + lChild,
                           match.substring(0, match.length - 1) + lChar,
                           candidates, origPrefix);
      }

      if (rChild != 0) {
        var rChar = String.fromCharCode(_dict[offset + rChild]);
        findPredictionsDFS(offset + rChild,
                           match.substring(0, match.length - 1) + rChar,
                           candidates, origPrefix);
      }
    }

    // origPrefix indicates that the prefix was not modified through
    // insertion, deletion, transposition of characters
    function predict(offset, prefix, prefixLength, match, suggestions, origPrefix) {

      var matchLength = match.length;

      if (matchLength > prefixLength)
        return;

      var splitChar = _dict[offset]; // character code
      var lChild = _dict[offset + lChildIdx];
      var cChild = _dict[offset + cChildIdx];
      var rChild = _dict[offset + rChildIdx];
      var frequency = _dict[offset + freqIdx];

      var ch = prefix[matchLength];
      if (ch == splitChar && cChild != 0) {
        var chStr = String.fromCharCode(ch);
        if (prefixLength - matchLength == 1) {
          var cChar = String.fromCharCode(_dict[offset + cChild]);
          findPredictionsDFS(offset + cChild,
                             match + String.fromCharCode(splitChar) + cChar,
                             suggestions, origPrefix);
          return;
        }
        predict(offset + cChild, prefix, prefixLength,
                match + chStr, suggestions, origPrefix);

        if (origPrefix && prefixLength > 1) {

          // //////////////////////////////////////////////////
          // Creating alternative candidates by:
          /////////////////////////////////////////////////////
          
          /////////////////////////////////////////////////////
          // a) adding a character

          // move() works like memcpy, we move all charCodes to the right
          // to make room for adding one character
          prefix.move(matchLength + 1, prefix.length - matchLength - 1, matchLength + 2);
          for (var nkey in _nearbyKeys) {
            prefix[matchLength + 1] = nkey.charCodeAt(0);
            predict(offset + cChild, prefix, prefixLength + 1,
                    match + chStr, suggestions, false);
          }
          // move the memory back where it was
          prefix.move(matchLength + 2, prefix.length - matchLength - 1, matchLength + 1);

          /////////////////////////////////////////////////////
          // b) removing a character
          var removed = prefix[matchLength + 1];
          prefix.move(matchLength + 2, prefix.length - matchLength - 1, matchLength + 1);
          predict(offset + cChild, prefix, prefixLength - 1,
                  match + chStr, suggestions, false);
          prefix.move(matchLength + 1, prefix.length - matchLength - 1, matchLength + 2);
          prefix[matchLength + 1] = removed;


          if (prefixLength >= 2) {

            /////////////////////////////////////////////////////
            // c) replacing a character with its
            //    surrounding characters (editdistance 1)

            var nearbyKeys = _nearbyKeys[String.fromCharCode(prefix[matchLength + 1])];
            if (typeof(nearbyKeys) !== 'undefined') {
              var original = prefix[matchLength + 1];
              for (var i = 0, len = nearbyKeys.length; i < len; ++i) {
                prefix[matchLength + 1] = nearbyKeys[i].charCodeAt(0);
                predict(offset + cChild, prefix, prefixLength,
                        match + chStr, suggestions, false);
              }
              prefix[matchLength + 1] = original;
            }

            /////////////////////////////////////////////////////
            // d) replacing one character with its
            //    alternative keys (diacritics)

            var altKeys = _diacritics[String.fromCharCode(prefix[matchLength + 1]).toLowerCase()];
            if (typeof(altKeys) !== 'undefined') {
              var original = prefix[match.length + 1];
              for (var i = 0, len = altKeys.length; i < len; ++i) {
                prefix[matchLength + 1] = altKeys[i].charCodeAt(0);
                predict(offset + cChild, prefix, prefixLength,
                        match + chStr, suggestions, false);
              }
              prefix[matchLength + 1] = original;
            }

            /////////////////////////////////////////////////////
            // e) transposing characters

            if (prefix.length >= 3) {
              var idx1 = prefix[matchLength + 1];
              var idx2 = prefix[matchLength + 2];
              prefix[matchLength + 1] = idx2;
              prefix[matchLength + 2] = idx1;
              predict(offset + cChild, prefix, prefixLength,
                      match + chStr, suggestions, false);
              prefix[matchLength + 1] = idx1;
              prefix[matchLength + 2] = idx2;
            }
          }
        }
      }

      // traverse the left and right childnodes
      if (ch < splitChar && lChild != 0) {
        predict(offset + lChild, prefix, prefixLength, match, suggestions, origPrefix);
      }
      if (ch > splitChar && rChild != 0) {
        predict(offset + rChild, prefix, prefixLength, match, suggestions, origPrefix);
      }
    }

    function getPredictions(prefix, suggestions) {
      var prefixLength = prefix.length;
      // we can only handle words up to _maxWordLength - 1
      // because we squeeze in a character when generating
      // candidates
      if (prefixLength > _maxWordLength - 1)
        return;

      var input = String2Codes(new Uint32Array(_maxWordLength), prefix);
      predict(0, input, prefixLength, '', suggestions, true);

      if (suggestions.length >= 3)
        return;

      // if we don't find at least 3 candidates, we replace
      // the first character with all possible upper and
      // lower case characters
      for (var altkey in _nearbyKeys) {
        input[0] = altkey.charCodeAt(0);
        predict(0, input, prefixLength, '', suggestions, false);
        input[0] = altkey.toUpperCase().charCodeAt(0);
        predict(0, input, prefixLength, '', suggestions, false);
      }
      
      if (suggestions.length >= 3)
        return;

      // if we still don't have at least 3 candidates, we replace
      // the first character with available diacritics for
      // that character.
      var altkeys = _diacritics[prefix[0].toLowerCase()];
      if (typeof(altkeys) === 'undefined')
        return;

      for (var altkey in altkeys) {
        input[0] = altkey.charCodeAt(0);
        predict(0, input, prefixLength, '', suggestions, false);
      }
    }

    return (function(prefix, candidates) {
      getPredictions(prefix, candidates);
    });
  })();

  function maintainTopCandidates(topCandidates, candidate) {
    var length = topCandidates.length;
    var index = length;
    for (var i = length - 1; i >= 0; i--) {
      if (candidate.word == topCandidates[i].word)
        return;
      if (candidate.freq > topCandidates[i].freq)
        index = i;
    }
    if (index >= _maxSuggestions)
      return;
    topCandidates.splice(index, 0, candidate);
    if (topCandidates.length > _maxSuggestions)
      topCandidates.length = _maxSuggestions;
  }
 
  function Predict(word) {
    _currentWord = word;
    var candidates = [];
 
    SearchTST(word, candidates);

    // rank candidates
    var finalCandidates = [];
    for (var n = 0, len = candidates.length; n < len; ++n) {
      var candidate = candidates[n];
      maintainTopCandidates(finalCandidates, candidate);
    }
    return finalCandidates;
  }

  function setDictionary(dict) {
    _dict = Int32Array(dict);
  }

  function setLayout(params) {
    // For each key, calculate the keys nearby.
    var keyWidth = params.keyWidth;
    var keyHeight = params.keyHeight;
    var threshold = Math.min(keyWidth, keyHeight) * 1.2;
    var keyArray = params.keyArray;
    _nearbyKeys = {};
    threshold *= threshold;
    for (var n = 0; n < keyArray.length; ++n) {
      var key1 = keyArray[n];
      if (SpecialKey(key1))
        continue;
      var list = '';
      for (var m = 0; m < keyArray.length; ++m) {
        var key2 = keyArray[m];
        if (SpecialKey(key2))
          continue;
        if (SquaredDistanceToEdge(/* key dimensions */
          key1.x, key1.y,
          key1.width, key1.height,
          /* center of candidate key */
          key2.x + key2.width / 2,
          key2.y + key2.height / 2) <
            threshold) {
          list += String.fromCharCode(key2.code).toLowerCase();
        }
      }
      _nearbyKeys[String.fromCharCode(key1.code).toLowerCase()] = list;
    }
  }

  // Return an array of predictions for the given prefix
  function predict(prefix) {
    try {
    if (!_dict || !_nearbyKeys) {
      throw Error('not initialized');
    }

    // Get the raw predictions
    var predictions = Predict(prefix);
    }
    catch (e) {
      dump ("exception: " + e + "\n");
    }

    var finalPredictions = [];


    // Extract just the words and return an array of strings
    for (var n = 0, len = predictions.length; n < len; ++n) {
      finalPredictions.push(predictions[n].word);
    }
    return finalPredictions;
  }

  return {
    setDictionary: setDictionary,
    setLayout: setLayout,
    predict: predict
  };
}());
